<%
title = 'grpc'
description = 'The GRPC protocol support provided by mountebank'
%>

<% include ../../_header %>

<h1>grpc</h1>

<p>The GRPC protocol enables virtualizing a GRPC server, in a manner as similar
as possible to other Mountebank supported protocols, enabling you to quickly
test GRPC based microservices with mocked dependencies.</p>

<h2>Currently Unsupported</h2>

<ul>
  <li>TLS</li>
  <li>Streaming calls</li>
</ul>

<h2>Imposter Creation Parameters</h2>

<table>
  <tr>
    <th>Parameter</th>
    <th>Options</th>
    <th>Required?</th>
    <th>Default</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>protocol</code></td>
    <td><code>grpc</code></td>
    <td>Yes</td>
    <td>N/A</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><code>port</code></td>
    <td>Any valid port number</td>
    <td>No</td>
    <td>A randomly assigned port.  mountebank will return the actual value
    in the <code>POST</code> response.</td>
    <td>The port to run the imposter on.</td>
  </tr>
  <!-- ]
  <tr>
    <td><code>key</code></td>
    <td>A PEM-formatted string</td>
    <td>No</td>
    <td>A built in private key</td>
    <td>The GRPC server private key</td>
  </tr>
  -->
  <!--
  <tr>
    <td><code>cert</code></td>
    <td>A PEM-formatted string</td>
    <td>No</td>
    <td>A built in self-signed certificate</td>
    <td>The GRPC server certificate</td>
  </tr>
   -->
  <!--
  <tr>
    <td><code>mutualAuth</code></td>
    <td><code>true</code> or <code>false</code></td>
    <td>No</td>
    <td><code>false</code></td>
    <td>If <code>true</code>, the server will request a client certificate.
    Since the goal is simply to virtualize a server requiring mutual auth,
    invalid certificates will not be rejected.</td>
  </tr>
  -->
  <!--
  <tr>
    <td><code>name</code></td>
    <td>Any string</td>
    <td>No</td>
    <td>empty string</td>
    <td>Included in the logs, useful when multiple imposters are set up.</td>
  </tr>
   -->
  <tr>
    <td><code>protos</code></td>
    <td>Valid protocol buffer definitions</td>
    <td>No</td>
    <td>An empty array</td>
    <td>The list of protocol buffer messages and fields. We use <a
    href="https://github.com/protobufjs/protobuf.js">protobuf.js</a> for
    defining these, specifically their <a
    href="https://github.com/protobufjs/protobuf.js#using-json-descriptors">JSON
    descriptors</a>. See <a href="#defining-protocol-buffers">Defining Protocol
    Buffers</a> below.</td>
  </tr>
  <tr>
    <td><code>stubs</code></td>
    <td>Valid stubs</td>
    <td>No</td>
    <td>An empty array</td>
    <td>The list of stubs responsible for matching a request and returning a
    response.</td>
  </tr>
  <tr>
    <td><code>defaultResponse</code></td>
    <td>A valid response</td>
    <td>No</td>
    <td><pre><code>{
  code: grpc.status.UNIMPLEMENTED,
  message: 'unimplemented'
}</code></pre></td>
    <td>The default response to send if no predicate matches</td>
  </tr>
</table>

<h2>GRPC Requests</h2>

<table>
  <tr>
    <th>Field</th>
    <th>Description</th>
    <th>Type</th>
  </tr>
  <tr>
    <td><code>methodName</code></td>
    <td>The fully qualified method name, represented as
    "&lt;namespace&gt;.&lt;service&gt;.&lt;method&gt;", e.g.
    "helloworld.Greeter.SayHello".</td>
    <td>string</td>
</tr>
<tr>
    <td><code>responseType</code></td>
    <td>The fully qualified protobuf response type of the request, represented
    as "&lt;namespace&gt;.&lt;message&gt;", e.g. "helloworld.HelloReply".</td>
    <td>string</td>
  </tr>
  <tr>
    <td><code>request</code></td>
    <td>The raw GRPC request object.</td>
    <td>object</td>
  </tr>
</table>

<h2 id='defining-protocol-buffers'>Defining Protocol Buffers</h2>

<p>Protocol Buffers are defined using the JSON descriptor syntax of <a
href="https://github.com/protobufjs/protobuf.js">protobuf.js</a>: see <a
href="https://github.com/protobufjs/protobuf.js#using-json-descriptors">https://github.com/protobufjs/protobuf.js#using-json-descriptors</a>
for the canonical documentation.</p>

<p>In short:</p>

<ul>
  <li>Your <code>protos</code> imposter key should have one child per protobuf namespace.</li>
  <li>Within each namespace definition you should have one child per service or message type.</li>
  <li>Services should have a single child key: <code>methods</code>.</li>
  <li>Under <code>methods</code> you should define each method for the service.</li>
  <li>Each method should have a <code>requestType</code> and a <code>responseType</code>.</li>
  <li>Message types should have a single child key: <code>fields</code>.</li>
  <li>Under <code>fields</code> you should define each field for the message type.</li>
  <li>Each field should have a <code>type</code> and an <code>id</code>.</li>
  <li>
    <code>type</code> defines the data type of the field (e.g. string, int32, bool).
    See the <a href="https://github.com/protobufjs/protobuf.js#valid-message">protobuf.js valid message documentation</a> for a list of valid types.
  </li>
  <li><code>id</code> defines the numeric id of the field (e.g. 1, 2, 3).</li>
  <li>Just as with regular protobuf definitions, both client and server must agree on the type and id for each field.</li>
</ul>

<p>For example, the following JSON descriptor defines a protobuf matching the <a
href="https://github.com/grpc/grpc/blob/v1.22.0/examples/protos/helloworld.proto">official
protobuf hello world example</a>.</p>

<pre><code>"protos": {
  "helloworld": {
    "Greeter": {
      "methods": {
        "SayHello": { "requestType": "HelloRequest", "responseType": "HelloReply" }
      }
    },
    "HelloRequest": {
      "fields": {
        "name": { "type": "string", "id": 1 }
      }
    },
    "HelloReply": {
      "fields": {
        "message": { "type": "string", "id": 1 }
      }
    }
  }
}</code></pre>

<p>You should be able to use <a
href="https://github.com/protobufjs/protobuf.js#pbjs-for-javascript">pbjs</a> to
generate a JSON definition from a .proto file automatically.</p>
<!-- TODO: test that pbjs generates a correct JSON definition -->

<!-- TODO: example of a repeated field -->

<!-- TODO: example of a nested message -->

<!-- TODO: example of using one of the well known types -->

<h2>Stubs</h2>

<p>As with other Mountebank protocols, the <code>stubs</code> imposter section
defines predicates matching requests to the responses for that request. See <a
href="/docs/api/stubs">stubs</a> for full documentation on stubs in
Mountebank.</p>

<p>The following example <code>stubs</code> imposter section defines two stubs
using the "helloworld" protos.</p>

<pre><code>"stubs": [
  {
    "predicates": [
      { "equals": { "requestType": "helloworld.HelloRequest" } },
      { "equals": { "responseType": "helloworld.HelloResponse" } },
      { "equals": { "request": { "name": "John Smith" } } }
    ],
    "responses": [
      { "is": { "response": { "message": "Hello John!" } } },
      { "is": { "response": { "message": "Hello again John!" } } },
      { "is": { "error": { "code": 14, "message": "too many hello's" } } }
    ]
  },
  {
    "predicates": [
      { "equals": { "methodName": "helloworld.Greeter.SayHello" } }
    ],
    "responses": [
      { "is": { "response": { "message": "have we met?" } } }
    ]
  }
]</code></pre>

<p>For an incoming request of type
<code>HelloRequest</code>, where the response is type
<code>HelloResponse</code>, and where the
<code>HelloRequest</code> "name" field is equal to "John Smith", the imposter
will return <code>HelloResponse</code> responses where the "response" field is
"Hello John!"; then "Hello again John!"; then an error response of type
"unavailable" (see the <a
href="https://github.com/grpc/grpc/blob/v1.22.0/doc/statuscodes.md">GRPC error
codes documentation</a> for the list of all error codes).</p>

<p>For all requests to the <code>SayHello</code> endpoint that don't match the
earlier stub, the imposter will return a <code>HelloResponse</code> response
where the "response" field is "have we met?".</p>

<p>You should usually define the request type and/or service method (which
implies request type) if you're predicating on request. A predicate like
<code>{ "equals": { "request": {"name": "john smith" } } }</code> will never
match if the request type doesn't have a field called "name".</p>

<p>You should usually define the response type and/or service method if you're
sending a response. Sending a response that can't be serialized to the expected
protobuf response will fail with a warning in the logs.</p>
<!-- TODO: test that failure to serialize warns in the logs -->

<% include ../../_footer %>
